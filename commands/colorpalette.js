const sharp = require('sharp');
const Color = require('color');

class ColorPaletteGenerator {
  constructor() {
    this.paletteSize = 5;
    this.width = 1000;
    this.height = 500;
  }

  validateColorInput(input) {
    try {
      return input ? Color(input) : null;
    } catch (error) {
      return null;
    }
  }

  generateColorPalette(baseColor = null) {
    if (baseColor) {
      return [
        baseColor,
        baseColor.lighten(0.2),
        baseColor.darken(0.2),
        baseColor.rotate(30),
        baseColor.rotate(-30)
      ];
    }

    return Array.from({ length: this.paletteSize }, () => 
      Color.rgb([
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256)
      ])
    );
  }

  getColorFormats(color) {
    return {
      hex: color.hex(),
      hsl: color.hsl().string(),
      rgb: color.rgb().string(),
      rgba: color.alpha(1).rgb().string()
    };
  }

  async createPaletteImage(colors) {
    const colorBlockWidth = this.width / colors.length;

    const colorBlocks = colors.map((color, index) => {
      const hexColor = color.hex();
      const textColor = this.getContrastYIQ(hexColor);

      return {
        input: Buffer.from(`
          <svg xmlns="http://www.w3.org/2000/svg" width="${colorBlockWidth}" height="${this.height}">
            <rect 
              width="${colorBlockWidth}" 
              height="${this.height}" 
              fill="${hexColor}"
            />
            <text 
              x="50%" 
              y="50%" 
              text-anchor="middle" 
              font-family="Arial" 
              font-size="30" 
              font-weight="bold"
              fill="${textColor}"
            >
              ${hexColor.toUpperCase()}
            </text>
          </svg>
        `),
        left: index * colorBlockWidth,
        top: 0
      };
    });

    const watermarkSvg = Buffer.from(`
      <svg xmlns="http://www.w3.org/2000/svg" width="${this.width}" height="${this.height}">
        <text 
          x="50%" 
          y="${this.height - 50}" 
          text-anchor="middle" 
          font-family="Arial" 
          font-size="24" 
          fill="rgba(255,255,255,0.7)" 
          font-weight="bold"
        >
          Generated by Lumina Color Studio
        </text>
      </svg>
    `);

    const paletteImage = await sharp({
      create: {
        width: this.width,
        height: this.height,
        channels: 4,
        background: { r: 30, g: 30, b: 30, alpha: 1 }
      }
    })
    .composite([
      ...colorBlocks,
      {
        input: watermarkSvg,
        top: 0,
        left: 0,
        blend: 'over'
      }
    ])
    .png()
    .toBuffer();

    return paletteImage;
  }

  getContrastYIQ(hexcolor) {
    const r = parseInt(hexcolor.slice(1, 3), 16);
    const g = parseInt(hexcolor.slice(3, 5), 16);
    const b = parseInt(hexcolor.slice(5, 7), 16);
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? 'black' : 'white';
  }

  getLuminaErrorMessage(errorType) {
    const errorMessages = {
      invalidColor: [
        "Oops! ðŸ¤– I'm having trouble understanding that color. Could you try again with a valid color like 'red' or '#FF5733'?",
        "Hey there! ðŸŒˆ I'm a bit confused by the color you provided. Mind giving me a clear color name or hex code?",
        "Hmm... ðŸ§ That doesn't look like a color I recognize. Can you help me out with a standard color name or hex code?"
      ],
      generationFailed: [
        "Uh-oh! ðŸ˜… My color magic seems to have short-circuited. Let's try that again!",
        "Whoops! ðŸ”§ My color generator is feeling a bit shy today. Mind giving it another shot?",
        "Looks like my color crystals are a bit cloudy. Care to help me clear them up?"
      ]
    };

    const messages = errorMessages[errorType];
    return messages[Math.floor(Math.random() * messages.length)];
  }
}

module.exports = {
  name: 'colorpalette',
  description: 'Generate an advanced color palette with multiple formats and visual representation',
  
  async execute(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    await bot.sendChatAction(chatId, 'typing');

    let baseColor = null;
    if (args.length > 0) {
      baseColor = generator.validateColorInput(args[0]);
      
      if (!baseColor) {
        const errorMessage = generator.getLuminaErrorMessage('invalidColor');
        return bot.sendMessage(chatId, errorMessage);
      }
    }

    try {
      const colors = generator.generateColorPalette(baseColor);
      const colorFormats = colors.map(color => generator.getColorFormats(color));

      const formattedResponse = colorFormats.map((color, index) => 
        `ðŸŽ¨ Color ${index + 1}:\n` +
        `HEX: <code>${color.hex}</code>\n` +
        `HSL: <code>${color.hsl}</code>\n` +
        `RGB: <code>${color.rgb}</code>\n` +
        `RGBA: <code>${color.rgba}</code>\n`
      ).join('\n');

      const paletteImage = await generator.createPaletteImage(colors);

      await bot.sendPhoto(chatId, paletteImage, {
        caption: `ðŸŒˆ Generated Color Palette:\n\n${formattedResponse}`,
        parse_mode: 'HTML'
      });

    } catch (error) {
      console.error('Color Palette Generation Error:', error);
      const errorMessage = generator.getLuminaErrorMessage('generationFailed');
      await bot.sendMessage(chatId, errorMessage);
    }
  },

  async complementaryPalette(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    await bot.sendChatAction(chatId, 'typing');

    try {
      const baseColor = generator.validateColorInput(args[0]);
      
      if (!baseColor) {
        const errorMessage = generator.getLuminaErrorMessage('invalidColor');
        return bot.sendMessage(chatId, errorMessage);
      }

      const complementaryColor = Color(baseColor).rotate(180);
      
      const colors = [
        baseColor, 
        complementaryColor, 
        baseColor.lighten(0.2), 
        complementaryColor.lighten(0.2), 
        baseColor.darken(0.2)
      ];

      const colorFormats = colors.map(color => generator.getColorFormats(color));

            const formattedResponse = colorFormats.map((color, index) => 
        `ðŸŽ¨ Color ${index + 1}:\n` +
        `HEX: <code>${color.hex}</code>\n` +
        `HSL: <code>${color.hsl}</code>\n` +
        `RGB: <code>${color.rgb}</code>\n` +
        `RGBA: <code>${color.rgba}</code>\n`
      ).join('\n');

      const paletteImage = await generator.createPaletteImage(colors);

      await bot.sendPhoto(chatId, paletteImage, {
        caption: `ðŸŒˆ Complementary Color Palette:\n\n${formattedResponse}`,
        parse_mode: 'HTML'
      });

    } catch (error) {
      console.error('Complementary Palette Generation Error:', error);
      const errorMessage = generator.getLuminaErrorMessage('generationFailed');
      await bot.sendMessage(chatId, errorMessage);
    }
  },

  async analogousPalette(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    await bot.sendChatAction(chatId, 'typing');

    try {
      const baseColor = generator.validateColorInput(args[0]);
      
      if (!baseColor) {
        const errorMessage = generator.getLuminaErrorMessage('invalidColor');
        return bot.sendMessage(chatId, errorMessage);
      }

      const colors = [
        baseColor,
        baseColor.rotate(30),
        baseColor.rotate(-30),
        baseColor.lighten(0.2),
        baseColor.darken(0.2)
      ];

      const colorFormats = colors.map(color => generator.getColorFormats(color));

      const formattedResponse = colorFormats.map((color, index) => 
        `ðŸŽ¨ Color ${index + 1}:\n` +
        `HEX: <code>${color.hex}</code>\n` +
        `HSL: <code>${color.hsl}</code>\n` +
        `RGB: <code>${color.rgb}</code>\n` +
        `RGBA: <code>${color.rgba}</code>\n`
      ).join('\n');

      const paletteImage = await generator.createPaletteImage(colors);

      await bot.sendPhoto(chatId, paletteImage, {
        caption: `ðŸŒˆ Analogous Color Palette:\n\n${formattedResponse}`,
        parse_mode: 'HTML'
      });

    } catch (error) {
      console.error('Analogous Palette Generation Error:', error);
      const errorMessage = generator.getLuminaErrorMessage('generationFailed');
      await bot.sendMessage(chatId, errorMessage);
    }
  },

  async triadicPalette(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    await bot.sendChatAction(chatId, 'typing');

    try {
      const baseColor = generator.validateColorInput(args[0]);
      
      if (!baseColor) {
        const errorMessage = generator.getLuminaErrorMessage('invalidColor');
        return bot.sendMessage(chatId, errorMessage);
      }

      const colors = [
        baseColor,
        baseColor.rotate(120),
        baseColor.rotate(240),
        baseColor.lighten(0.2),
        baseColor.darken(0.2)
      ];

      const colorFormats = colors.map(color => generator.getColorFormats(color));

      const formattedResponse = colorFormats.map((color, index) => 
        `ðŸŽ¨ Color ${index + 1}:\n` +
        `HEX: <code>${color.hex}</code>\n` +
        `HSL: <code>${color.hsl}</code>\n` +
        `RGB: <code>${color.rgb}</code>\n` +
        `RGBA: <code>${color.rgba}</code>\n`
      ).join('\n');

      const paletteImage = await generator.createPaletteImage(colors);

      await bot.sendPhoto(chatId, paletteImage, {
        caption: `ðŸŒˆ Triadic Color Palette:\n\n${formattedResponse}`,
        parse_mode: 'HTML'
      });

    } catch (error) {
      console.error('Triadic Palette Generation Error:', error);
      const errorMessage = generator.getLuminaErrorMessage('generationFailed');
      await bot.sendMessage(chatId, errorMessage);
    }
  }
};
